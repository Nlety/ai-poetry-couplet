const STORAGE_KEY = 'ai_poetry_collection';
const API_BASE = '/api/poetry-storage';
async function getWorks() { try { const local = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); try { const r = await fetch(`${API_BASE}?action=list`); if (r.ok) { const c = await r.json(); if (c.works) { const m = mergeData(local, c.works); localStorage.setItem(STORAGE_KEY, JSON.stringify(m)); return m; } } } catch (e) { } return local; } catch (e) { return []; } }
function mergeData(local, cloud) { const map = new Map();[...local, ...cloud].forEach(r => { if (!map.has(r.id) || r.updatedAt > map.get(r.id).updatedAt) map.set(r.id, r); }); return Array.from(map.values()).sort((a, b) => b.createdAt - a.createdAt); }
async function saveWork(work) { try { const works = await getWorks(); const now = Date.now(); if (!work.id) { work.id = `poem_${now}_${Math.random().toString(36).slice(2, 8)}`; work.createdAt = now; } work.updatedAt = now; const index = works.findIndex(r => r.id === work.id); if (index >= 0) works[index] = work; else works.unshift(work); localStorage.setItem(STORAGE_KEY, JSON.stringify(works)); let cloudSync = false; try { const r = await fetch(API_BASE, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'save', work }) }); cloudSync = r.ok; } catch (e) { } return { success: true, cloudSync }; } catch (e) { return { success: false }; } }
window.StorageService = { getWorks, saveWork };
